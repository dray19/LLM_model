{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('gain')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of power_OBS grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of day_ahead grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['pred'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the min of gain grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['pred'].min()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of day_ahead grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['pred'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return bottom 133.0 rows by day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nsmallest(199.0, 'pred')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of day_ahead grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['pred'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of day_ahead grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['power_OBS'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of power_OBS. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['gain'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the min of pred grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['power_OBS'].min()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of power_OBS grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['gain'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is less than 171.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 197.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of gain grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['pred'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['power_OBS'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is less than 23.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 55.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return bottom 45.0 rows by gain. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nsmallest(169.0, 'day_ahead')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is greater than or equal to94.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['day_ahead'] >= 126.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of gain grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['power_OBS'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of power_OBS. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['day_ahead'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is greater than 107.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['power_OBS'] > 23.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by gain. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('pred')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is less than or equal to22.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] <= 107.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of power_OBS grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['day_ahead'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean and std of gain grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['gain'].agg(['mean','std'])"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is greater than 155.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] > 54.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['gain'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return bottom 99.0 rows by power_OBS. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nsmallest(179.0, 'day_ahead')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of day_ahead grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return top 20.0 rows by day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nlargest(22.0, 'power_OBS')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of power_OBS grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['pred'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is less than or equal to7.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['pred'] <= 141.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is less than or equal to48.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] <= 120.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is equal to0.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['power_OBS'] == 8.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is greater than or equal to173.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] >= 147.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of power_OBS grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['power_OBS'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where power_OBS is greater than or equal to68.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['pred'] >= 18.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Count unique values of pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['day_ahead'].nunique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by power_OBS. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('day_ahead')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return bottom 96.0 rows by day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nsmallest(1.0, 'day_ahead')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('day_ahead')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of gain. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['day_ahead'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the min of day_ahead grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['day_ahead'].min()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return bottom 31.0 rows by gain. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nsmallest(50.0, 'pred')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of pred grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is less than or equal to13.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['power_OBS'] <= 106.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Count unique values of day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['gain'].nunique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of gain grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['power_OBS'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['day_ahead'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of day_ahead grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['day_ahead'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of gain grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['pred'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of power_OBS. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['power_OBS'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is greater than 127.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['day_ahead'] > 38.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the min of power_OBS grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].min()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is less than 160.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['day_ahead'] < 113.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is greater than or equal to77.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] >= 128.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['power_OBS'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is greater than 136.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['pred'] > 179.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the min of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['power_OBS'].min()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['gain'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Count unique values of pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['power_OBS'].nunique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return bottom 62.0 rows by gain. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nsmallest(19.0, 'power_OBS')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where power_OBS is greater than 171.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['pred'] > 9.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is less than or equal to52.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] <= 119.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is greater than or equal to123.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['pred'] >= 130.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['gain'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of power_OBS. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['day_ahead'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows for a specific hour 107.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['INIT_DATE_TIME'].dt.hour == 42.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is less than or equal to72.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['day_ahead'] <= 11.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('day_ahead')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows for a specific hour 79.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['INIT_DATE_TIME'].dt.hour == 43.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is greater than or equal to109.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['power_OBS'] >= 172.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is less than or equal to195.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['power_OBS'] <= 77.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of power_OBS grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['pred'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the min of day_ahead grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].min()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is less than 178.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 166.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of gain. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['pred'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['pred'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return top 104.0 rows by pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nlargest(169.0, 'power_OBS')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['day_ahead'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return bottom 7.0 rows by day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nsmallest(75.0, 'gain')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is less than or equal to146.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['power_OBS'] <= 40.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of power_OBS grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['gain'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean and std of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['pred'].agg(['mean','std'])"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is less than or equal to43.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['day_ahead'] <= 80.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is greater than 175.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] > 183.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean and std of gain grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['power_OBS'].agg(['mean','std'])"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is less than or equal to199.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['day_ahead'] <= 95.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Count unique values of power_OBS. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['gain'].nunique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of day_ahead grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['pred'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Get unique values of day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['power_OBS'].unique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('pred')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of power_OBS grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of gain grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['gain'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('pred')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of power_OBS grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['pred'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of gain grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['power_OBS'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Return bottom 99.0 rows by day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.nsmallest(39.0, 'pred')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Count unique values of day_ahead. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['power_OBS'].nunique()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where power_OBS is less than 125.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 59.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the sum of gain grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['gain'].sum()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is less than or equal to51.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['pred'] <= 81.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows for a specific hour 112.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['INIT_DATE_TIME'].dt.hour == 119.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is greater than 129.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] > 51.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is greater than or equal to101.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] >= 178.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute count of rows grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ').size()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where day_ahead is greater than 25.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] > 155.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by gain. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('day_ahead')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by power_OBS. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('gain')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is less than or equal to22.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['power_OBS'] <= 162.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where pred is equal to109.0. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] == 53.0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Extract hour from INIT_DATE_TIME. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df['hour'] = df['INIT_DATE_TIME'].dt.hour"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of day_ahead grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['day_ahead'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the min of day_ahead grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['power_OBS'].min()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the max of gain grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['power_OBS'].max()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of pred grouped by models. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('models')['day_ahead'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Compute the mean of pred grouped by LZ. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.groupby('LZ')['day_ahead'].mean()"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Sort the DataFrame by pred. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df.sort_values('pred')"}
{"messages": [{"role": "system", "content": "You are a code generator. Respond with ONLY valid Python code. No explanations. No markdown. No imports. NO sample data.\n\nRules:\n- You MUST assume a pandas DataFrame named df already exists in memory and is the ONLY input dataset.\n- Generate code that operates ONLY on df or intermediate objects derived directly from df.\n- Do NOT reference external variables, files, paths, configs, or objects not derived from df.\n- Do NOT read from or write to disk.\n- Do NOT make network calls.\n- Do NOT use randomness or non-deterministic behavior.\n- Do NOT use unsafe operations (eval, exec, compile, ast, subprocess, os, shell commands).\n- Do NOT mutate df unless explicitly requested; prefer creating new objects.\n- Avoid chained assignment; use .loc for assignments.\n- Do NOT assume column dtypes; handle numeric vs non-numeric safely.\n- For groupby aggregations, use numeric_only=True when appropriate.\n- Guard against missing columns: if required columns are missing, assign result to a clear error string like \"ERROR: missing columns: ['col1', 'col2']\".\n- Always assign the final output to a variable named result.\n- Do NOT print unless explicitly requested.\n- Keep the code minimal, deterministic, and directly executable."}, {"role": "user", "content": "Filter rows where gain is negative. \nColumns: INIT_DATE_TIME, LZ, models, power_OBS, day_ahead, pred, gain"}], "expected": "df[df['gain'] < 0]"}
